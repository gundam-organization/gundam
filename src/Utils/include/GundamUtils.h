//
// Created by Adrien Blanchet on 21/05/2023.
//

#ifndef GUNDAM_GUNDAMUTILS_H
#define GUNDAM_GUNDAMUTILS_H


#include "GenericToolbox.String.h"
#include "GenericToolbox.Root.h"
#include "CmdLineParser.h"
#include "Logger.h"

#include "TDirectory.h"
#include "TObject.h"

#include <map>
#include <string>
#include <vector>
#include <utility>
#include <functional>



namespace GundamUtils {

  // forward version config that was auto generated by CMake
  std::string getVersionStr();
  std::string getVersionFullStr();
  std::string getSourceCodePath();
  bool isNewerOrEqualVersion( const std::string& minVersion_ );

  std::string generateFileName(const CmdLineParser& clp_, const std::vector<std::pair<std::string, std::string>>& appendixDict_);

  // dicts
  static const std::map<int, std::string> minuitStatusCodeStr{
      { 0 , "status = 0    : OK" },
      { 1 , "status = 1    : Covariance was mad! Thus made pos defined"},
      { 2 , "status = 2    : Hesse is invalid"},
      { 3 , "status = 3    : Edm is above max"},
      { 4 , "status = 4    : Reached call limit"},
      { 5 , "status = 5    : Any other failure"},
      { -1, "status = -1   : We don't even know what happened"}
  };
  static const std::map<int, std::string> hesseStatusCodeStr{
      { 0, "status = 0    : OK" },
      { 1, "status = 1    : Hesse failed"},
      { 2, "status = 2    : Matrix inversion failed"},
      { 3, "status = 3    : Matrix is not pos defined"},
      { -1, "status = -1    : Minimize wasn't called before"}
  };
  static const std::map<int, std::string> minosStatusCodeStr{
      { 0, "status = 0    : last MINOS run was succesfull" },
      { 1, "status = 1    : Maximum number of function calls exceeded when running for lower error"},
      { 2, "status = 2    : maximum number of function calls exceeded when running for upper error"},
      { 3, "status = 3    : new minimum found when running for lower error"},
      { 4, "status = 4    : new minimum found when running for upper error"},
      { 5, "status = 5    : any other failure"},
      { -1, "status = -1   : Minos is not run"}
  };

  // 0 not calculated 1 approximated 2 made pos def , 3 accurate
  static const std::map<int, std::string> covMatrixStatusCodeStr{
      { 0, "status = 0    : not calculated" },
      { 1, "status = 1    : approximated"},
      { 2, "status = 2    : made pos def"},
      { 3, "status = 3    : accurate"}
  };

  class ObjectReader{

  public:
    template<typename T> static bool readObject( TDirectory* f_, const std::vector<std::string>& objPathList_, const std::function<void(T*)>& action_ = [](T*){} ){
      using namespace GenericToolbox::ColorCodes;
      T* obj;
      for( auto& objPath : objPathList_ ){
        obj = f_->Get<T>(objPath.c_str());
        if( obj != nullptr ){ break; }
      }
      if( obj == nullptr ){
        LogErrorIf(not ObjectReader::quiet) << redLightText << "Could not find object among names: " << resetColor << GenericToolbox::toString(objPathList_) << std::endl;
        LogThrowIf(ObjectReader::throwIfNotFound, "Object not found.");
        return false;
      }
      action_(obj);
      return true;
    }
    template<typename T> static bool readObject( TDirectory* f_, const std::string& objPath_, const std::function<void(T*)>& action_ = [](T*){} ){ return readObject(f_, std::vector<std::string>{objPath_}, action_); }
    static bool readObject( TDirectory* f_, const std::string& objPath_);

    static bool quiet;
    static bool throwIfNotFound;

  };

  inline void throwCorrelatedParameters(TMatrixD* choleskyCovMatrix_, std::vector<double>& thrownParListOut_){
      if( choleskyCovMatrix_ == nullptr ) return;
      if( thrownParListOut_.size() != choleskyCovMatrix_->GetNcols() ){
          thrownParListOut_.resize(choleskyCovMatrix_->GetNcols(), 0);
      }
      TVectorD thrownParVec(choleskyCovMatrix_->GetNcols());
      for( int iPar = 0 ; iPar < choleskyCovMatrix_->GetNcols() ; iPar++ ){
          thrownParVec[iPar] = gRandom->Gaus();
      }
      thrownParVec *= (*choleskyCovMatrix_);
      for( int iPar = 0 ; iPar < choleskyCovMatrix_->GetNcols() ; iPar++ ){
          thrownParListOut_.at(iPar) = thrownParVec[iPar];
      }
  }// end of function throwCorrelatedParameters(TMatrixD* choleskyCovMatrix_, std::vector<double>& thrownParListOut_)
  inline std::vector<double> throwCorrelatedParameters(TMatrixD* choleskyCovMatrix_){
      std::vector<double> out;
      throwCorrelatedParameters(choleskyCovMatrix_, out);
      return out;
  }// end of function throwCorrelatedParameters(TMatrixD* choleskyCovMatrix_)
  inline void throwCorrelatedParameters(  TMatrixD* choleskyCovMatrix_, std::vector<double>& thrownParListOut_, std::vector<double>& weights,
                                          double pedestalEntity, double pedestalLeftEdge, double pedestalRightEdge
  ){

      double pi = TMath::Pi();
      double NormalizingFactor = 1.0 / (TMath::Sqrt(2.0 * pi));
      double pedestalRange = pedestalRightEdge - pedestalLeftEdge;
      if( choleskyCovMatrix_ == nullptr ) return;
      if( thrownParListOut_.size() != choleskyCovMatrix_->GetNcols() ){
          thrownParListOut_.resize(choleskyCovMatrix_->GetNcols(), 0);
      }
      weights.resize(choleskyCovMatrix_->GetNcols(), 0);
      LogInfo << "Resizing weights vector to " << choleskyCovMatrix_->GetNcols() << std::endl;
      for( int iPar = 0 ; iPar < choleskyCovMatrix_->GetNcols() ; iPar++ ){
          weights.at(iPar) = 0;
      }

      TVectorD thrownParVec(choleskyCovMatrix_->GetNcols());
      double choice = gRandom->Uniform(0,1);
      if (choice>pedestalEntity) {
          for (int iPar = 0; iPar < choleskyCovMatrix_->GetNcols(); iPar++) {
              thrownParVec[iPar] = gRandom->Gaus();
              if (thrownParVec[iPar]>pedestalLeftEdge and thrownParVec[iPar]<pedestalRightEdge){
                  weights.at(iPar) = -TMath::Log(
                          pedestalEntity*1.0/pedestalRange + (1.0-pedestalEntity) * NormalizingFactor * TMath::Exp(-0.500 * thrownParVec[iPar] * thrownParVec[iPar])
                  );
                  LogInfo<<"{GUndamUtils} weights["<<iPar<<"] = "<<weights.at(iPar)<<"\n";
              }else{
                  weights.at(iPar) = -TMath::Log((1.0-pedestalEntity) * NormalizingFactor )
                                          + 0.500 * thrownParVec[iPar] * thrownParVec[iPar];
                  LogInfo<<"{GundamUtils} weights["<<iPar<<"] = "<<weights.at(iPar)<<"\n";
              }
          }
      }else{
          for (int iPar = 0; iPar < choleskyCovMatrix_->GetNcols(); iPar++) {
              thrownParVec[iPar] = gRandom->Uniform(pedestalLeftEdge, pedestalRightEdge);
              weights.at(iPar) = -TMath::Log(
                      pedestalEntity*1.0/pedestalRange + (1.0-pedestalEntity) * NormalizingFactor * TMath::Exp(-0.500 * thrownParVec[iPar] * thrownParVec[iPar])
              );
          }
      }
      thrownParVec *= (*choleskyCovMatrix_);
      for( int iPar = 0 ; iPar < choleskyCovMatrix_->GetNcols() ; iPar++ ){
          thrownParListOut_.at(iPar) = thrownParVec[iPar];
      }
  }// end of function throwCorrelatedParameters(TMatrixD* choleskyCovMatrix_, std::vector<double>& thrownParListOut_, std::vector<double>& weights, double pedestalEntity, double pedestalLeftEdge, double pedestalRightEdge)

  inline void throwCorrelatedParameters(TMatrixD* choleskyCovMatrix_, std::vector<double>& thrownParListOut_, std::vector<double>& weights){
      throwCorrelatedParameters(choleskyCovMatrix_, thrownParListOut_, weights, 0, 0, 0);
  }// end of function throwCorrelatedParameters(TMatrixD* choleskyCovMatrix_, std::vector<double>& thrownParListOut_, std::vector<double>& weights)

  inline void throwTStudentParameters(TMatrixD* choleskyCovMatrix_, double nu_, std::vector<double>& thrownParListOut_, std::vector<double>& weights){
      // Simple sanity check
      if( choleskyCovMatrix_ == nullptr ) return;
      if( thrownParListOut_.size() != choleskyCovMatrix_->GetNcols() ){
          thrownParListOut_.resize(choleskyCovMatrix_->GetNcols(), 0);
      }
      if( weights.size() != choleskyCovMatrix_->GetNcols() ){
          weights.resize(choleskyCovMatrix_->GetNcols(), 0);
      }
      // Throw N independent normal distributions
      TVectorD thrownParVec(choleskyCovMatrix_->GetNcols());
      for( int iPar = 0 ; iPar < choleskyCovMatrix_->GetNcols() ; iPar++ ){
          thrownParVec[iPar] = gRandom->Gaus();
      }
      // Multiply by cov matrix to obtain the gaussian part of the t-student (expanded as the covariance matrix says)
      TVectorD thrownParVecExpanded = (*choleskyCovMatrix_)*thrownParVec;
      std::vector<double> chiSquareForStudentT(choleskyCovMatrix_->GetNcols());
      int p = 1; // because only THEN I sum over all dimensions. At this level it's all independent single-dim variables
      for( int iPar = 0 ; iPar < choleskyCovMatrix_->GetNcols() ; iPar++ ){
          // Throw a chisquare with nu_ degrees of freedom
          double chiSquareProb = gRandom->Uniform(0,1);
          chiSquareForStudentT.at(iPar) = TMath::ChisquareQuantile(chiSquareProb, nu_);
          // Build the t-student throw by multiplying the multivariate gaussian (with input cov. matrix) and the chisquare
          thrownParListOut_.at(iPar) = thrownParVecExpanded[iPar] * sqrt(nu_/chiSquareForStudentT.at(iPar));
          // Fill the weights vector now (according to the pdf of the t-student multivariate distribution)
          double logFactor1 = TMath::LnGamma(0.5*(nu_+p)) - TMath::LnGamma(0.5*nu_);
          double logDenominator =  + (0.5*p)*TMath::Log(nu_*TMath::Pi());
          double normalizedTStudentThrow = thrownParVec[iPar] * sqrt(nu_/chiSquareForStudentT.at(iPar));
          double logFactor2 = -0.5*(nu_+p)*TMath::Log( 1 + 1/nu_*normalizedTStudentThrow*normalizedTStudentThrow );
          weights.at(iPar) = -(logFactor1) +(logDenominator) - logFactor2;
          //std::cout<<p<<" "<<nu_<<"  "<<-(logFactor1)<<"  "<<+logDenominator<<"  "<<-logFactor2<<std::endl;
      }

  }// end of function throwTStudentParameters(TMatrixD* choleskyCovMatrix_, double nu_, std::vector<double>& thrownParListOut_, std::vector<double>& weights)

}

#endif //GUNDAM_GUNDAMUTILS_H
